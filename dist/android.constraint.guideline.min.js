this.android=this.android||{},this.android.constraint=this.android.constraint||{},this.android.constraint.guideline=function(){"use strict";var t=squared.base.LayoutUI;const{CONTAINER_NODE:n}=android.lib.constant,{formatPX:i}=squared.lib.css,{hypotenuse:a}=squared.lib.math,{withinRange:e}=squared.lib.util;function o(t){const n=t.bounds;return{x:(n.left+n.right)/2,y:(n.top+n.bottom)/2}}class Guideline extends squared.base.ExtensionUI{constructor(){super(...arguments),this.options={circlePosition:!0}}is(t){return this.included(t.element)}condition(t){return!t.isEmpty()}processNode(n,i){return{output:this.application.renderNode(new t(i,n,19,16))}}postBaseLayout(t){const n=this.controller,r=this.options.circlePosition,{left:s,top:c}=t.box;let d;if(t.each((t=>{const n=t.linear;e(n.left,s)&&t.anchorParent("horizontal",0),e(n.top,c)&&t.anchorParent("vertical",0),r&&(t.anchored?d=t:d?t.constraint.vertical&&!d.constraint.vertical&&(d=t):(t.constraint.vertical||t.constraint.horizontal)&&(d=t)),t.positioned=!0})),r){d||(d=t.item(0)),d.anchored||n.addGuideline({target:d,parent:t});const{x:e,y:r}=o(d);t.each((t=>{if(!t.anchored){const{x:n,y:s}=o(t),c=Math.abs(n-e),l=Math.abs(s-r),u=Math.round(a(c,l));let h=Math.round(Math.atan(Math.min(c,l)/Math.max(c,l))*(180/Math.PI));s>r?n>e?c>l?h+=90:h=180-h:c>l?h=270-h:h+=180:s<r?e>n?c>l?h+=270:h=360-h:c>l&&(h=90-h):h=n>e?90:270,t.app("layout_constraintCircle",d.documentId),t.app("layout_constraintCircleRadius",i(u)),t.app("layout_constraintCircleAngle",h.toString())}}))}else t.each((i=>{i.anchored||n.addGuideline({target:i,parent:t})}))}}const r=new Guideline("android.constraint.guideline",2);return squared&&squared.add(r),r}();
